(()=>{"use strict";var e={360:(e,t,r)=>{t.sc=ce,t.eN=function e(t,r,n){if(n instanceof class{constructor(e={}){this.value=(0,s.getParametersValue)(e,"value",[]),this.optional=(0,s.getParametersValue)(e,"optional",!1)}}){const s=!1;for(let s=0;s<n.value.length;s++)if(!0===e(t,r,n.value[s]).verified)return{verified:!0,result:t};if(!1===s){const e={verified:!1,result:{error:"Wrong values for Choice type"}};return n.hasOwnProperty("name")&&(e.name=n.name),e}}if(n instanceof oe)return n.hasOwnProperty("name")&&(t[n.name]=r),{verified:!0,result:t};if(t instanceof Object==0)return{verified:!1,result:{error:"Wrong root object"}};if(r instanceof Object==0)return{verified:!1,result:{error:"Wrong ASN.1 data"}};if(n instanceof Object==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("idBlock"in n==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("fromBER"in n.idBlock==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("toBER"in n.idBlock==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const i=n.idBlock.toBER(!1);if(0===i.byteLength)return{verified:!1,result:{error:"Error encoding idBlock for ASN.1 schema"}};if(-1===n.idBlock.fromBER(i,0,i.byteLength))return{verified:!1,result:{error:"Error decoding idBlock for ASN.1 schema"}};if(!1===n.idBlock.hasOwnProperty("tagClass"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(n.idBlock.tagClass!==r.idBlock.tagClass)return{verified:!1,result:t};if(!1===n.idBlock.hasOwnProperty("tagNumber"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(n.idBlock.tagNumber!==r.idBlock.tagNumber)return{verified:!1,result:t};if(!1===n.idBlock.hasOwnProperty("isConstructed"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(n.idBlock.isConstructed!==r.idBlock.isConstructed)return{verified:!1,result:t};if("isHexOnly"in n.idBlock==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(n.idBlock.isHexOnly!==r.idBlock.isHexOnly)return{verified:!1,result:t};if(!0===n.idBlock.isHexOnly){if("valueHex"in n.idBlock==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const e=new Uint8Array(n.idBlock.valueHex),s=new Uint8Array(r.idBlock.valueHex);if(e.length!==s.length)return{verified:!1,result:t};for(let r=0;r<e.length;r++)if(e[r]!==s[1])return{verified:!1,result:t}}if(n.hasOwnProperty("name")&&(n.name=n.name.replace(/^\s+|\s+$/g,""),""!==n.name&&(t[n.name]=r)),!0===n.idBlock.isConstructed){let s=0,i={verified:!1},o=n.valueBlock.value.length;if(o>0&&n.valueBlock.value[0]instanceof le&&(o=r.valueBlock.value.length),0===o)return{verified:!0,result:t};if(0===r.valueBlock.value.length&&0!==n.valueBlock.value.length){let e=!0;for(let t=0;t<n.valueBlock.value.length;t++)e=e&&(n.valueBlock.value[t].optional||!1);return!0===e?{verified:!0,result:t}:(n.hasOwnProperty("name")&&(n.name=n.name.replace(/^\s+|\s+$/g,""),""!==n.name&&delete t[n.name]),t.error="Inconsistent object length",{verified:!1,result:t})}for(let l=0;l<o;l++)if(l-s>=r.valueBlock.value.length){if(!1===n.valueBlock.value[l].optional){const e={verified:!1,result:t};return t.error="Inconsistent length between ASN.1 data and schema",n.hasOwnProperty("name")&&(n.name=n.name.replace(/^\s+|\s+$/g,""),""!==n.name&&(delete t[n.name],e.name=n.name)),e}}else if(n.valueBlock.value[0]instanceof le){if(i=e(t,r.valueBlock.value[l],n.valueBlock.value[0].value),!1===i.verified){if(!0!==n.valueBlock.value[0].optional)return n.hasOwnProperty("name")&&(n.name=n.name.replace(/^\s+|\s+$/g,""),""!==n.name&&delete t[n.name]),i;s++}if("name"in n.valueBlock.value[0]&&n.valueBlock.value[0].name.length>0){let e={};e="local"in n.valueBlock.value[0]&&!0===n.valueBlock.value[0].local?r:t,void 0===e[n.valueBlock.value[0].name]&&(e[n.valueBlock.value[0].name]=[]),e[n.valueBlock.value[0].name].push(r.valueBlock.value[l])}}else if(i=e(t,r.valueBlock.value[l-s],n.valueBlock.value[l]),!1===i.verified){if(!0!==n.valueBlock.value[l].optional)return n.hasOwnProperty("name")&&(n.name=n.name.replace(/^\s+|\s+$/g,""),""!==n.name&&delete t[n.name]),i;s++}if(!1===i.verified){const e={verified:!1,result:t};return n.hasOwnProperty("name")&&(n.name=n.name.replace(/^\s+|\s+$/g,""),""!==n.name&&(delete t[n.name],e.name=n.name)),e}return{verified:!0,result:t}}if("primitiveSchema"in n&&"valueHex"in r.valueBlock){const s=ce(r.valueBlock.valueHex);if(-1===s.offset){const e={verified:!1,result:s.result};return n.hasOwnProperty("name")&&(n.name=n.name.replace(/^\s+|\s+$/g,""),""!==n.name&&(delete t[n.name],e.name=n.name)),e}return e(t,s.result,n.primitiveSchema)}return{verified:!0,result:t}},t.IK=t.rP=t.z8=t._K=t.fi=t.T9=void 0;var s=r(447);const n=[new Uint8Array([1])],i="0123456789";class o{constructor(e={}){this.blockLength=(0,s.getParametersValue)(e,"blockLength",0),this.error=(0,s.getParametersValue)(e,"error",""),this.warnings=(0,s.getParametersValue)(e,"warnings",[]),this.valueBeforeDecode="valueBeforeDecode"in e?e.valueBeforeDecode.slice(0):new ArrayBuffer(0)}static blockName(){return"baseBlock"}toJSON(){return{blockName:this.constructor.blockName(),blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:(0,s.bufferToHexCodes)(this.valueBeforeDecode,0,this.valueBeforeDecode.byteLength)}}}const l=e=>class extends e{constructor(e={}){super(e),this.isHexOnly=(0,s.getParametersValue)(e,"isHexOnly",!1),this.valueHex="valueHex"in e?e.valueHex.slice(0):new ArrayBuffer(0)}static blockName(){return"hexBlock"}fromBER(e,t,r){return!1===(0,s.checkBufferParams)(this,e,t,r)?-1:0===new Uint8Array(e,t,r).length?(this.warnings.push("Zero buffer length"),t):(this.valueHex=e.slice(t,t+r),this.blockLength=r,t+r)}toBER(e=!1){return!0!==this.isHexOnly?(this.error='Flag "isHexOnly" is not set, abort',new ArrayBuffer(0)):!0===e?new ArrayBuffer(this.valueHex.byteLength):this.valueHex.slice(0)}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.blockName=this.constructor.blockName(),e.isHexOnly=this.isHexOnly,e.valueHex=(0,s.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),e}};class a extends(l(o)){constructor(e={}){super(),"idBlock"in e?(this.isHexOnly=(0,s.getParametersValue)(e.idBlock,"isHexOnly",!1),this.valueHex=(0,s.getParametersValue)(e.idBlock,"valueHex",new ArrayBuffer(0)),this.tagClass=(0,s.getParametersValue)(e.idBlock,"tagClass",-1),this.tagNumber=(0,s.getParametersValue)(e.idBlock,"tagNumber",-1),this.isConstructed=(0,s.getParametersValue)(e.idBlock,"isConstructed",!1)):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}static blockName(){return"identificationBlock"}toBER(e=!1){let t,r,n=0;switch(this.tagClass){case 1:n|=0;break;case 2:n|=64;break;case 3:n|=128;break;case 4:n|=192;break;default:return this.error="Unknown tag class",new ArrayBuffer(0)}if(this.isConstructed&&(n|=32),this.tagNumber<31&&!this.isHexOnly){if(t=new ArrayBuffer(1),r=new Uint8Array(t),!e){let e=this.tagNumber;e&=31,n|=e,r[0]=n}return t}if(!1===this.isHexOnly){const i=(0,s.utilToBase)(this.tagNumber,7),o=new Uint8Array(i),l=i.byteLength;if(t=new ArrayBuffer(l+1),r=new Uint8Array(t),r[0]=31|n,!e){for(let e=0;e<l-1;e++)r[e+1]=128|o[e];r[l]=o[l-1]}return t}if(t=new ArrayBuffer(this.valueHex.byteLength+1),r=new Uint8Array(t),r[0]=31|n,!1===e){const e=new Uint8Array(this.valueHex);for(let t=0;t<e.length-1;t++)r[t+1]=128|e[t];r[this.valueHex.byteLength]=e[e.length-1]}return t}fromBER(e,t,r){if(!1===(0,s.checkBufferParams)(this,e,t,r))return-1;const n=new Uint8Array(e,t,r);if(0===n.length)return this.error="Zero buffer length",-1;switch(192&n[0]){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=32==(32&n[0]),this.isHexOnly=!1;const i=31&n[0];if(31!==i)this.tagNumber=i,this.blockLength=1;else{let e=1;this.valueHex=new ArrayBuffer(255);let t=255,r=new Uint8Array(this.valueHex);for(;128&n[e];){if(r[e-1]=127&n[e],e++,e>=n.length)return this.error="End of input reached before message was fully decoded",-1;if(e===t){t+=255;const e=new ArrayBuffer(t),s=new Uint8Array(e);for(let e=0;e<r.length;e++)s[e]=r[e];this.valueHex=new ArrayBuffer(t),r=new Uint8Array(this.valueHex)}}this.blockLength=e+1,r[e-1]=127&n[e];const i=new ArrayBuffer(e),o=new Uint8Array(i);for(let t=0;t<e;t++)o[t]=r[t];this.valueHex=new ArrayBuffer(e),r=new Uint8Array(this.valueHex),r.set(o),this.blockLength<=9?this.tagNumber=(0,s.utilFromBase)(r,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(1===this.tagClass&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return t+this.blockLength}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.blockName=this.constructor.blockName(),e.tagClass=this.tagClass,e.tagNumber=this.tagNumber,e.isConstructed=this.isConstructed,e}}class c extends o{constructor(e={}){super(),"lenBlock"in e?(this.isIndefiniteForm=(0,s.getParametersValue)(e.lenBlock,"isIndefiniteForm",!1),this.longFormUsed=(0,s.getParametersValue)(e.lenBlock,"longFormUsed",!1),this.length=(0,s.getParametersValue)(e.lenBlock,"length",0)):(this.isIndefiniteForm=!1,this.longFormUsed=!1,this.length=0)}static blockName(){return"lengthBlock"}fromBER(e,t,r){if(!1===(0,s.checkBufferParams)(this,e,t,r))return-1;const n=new Uint8Array(e,t,r);if(0===n.length)return this.error="Zero buffer length",-1;if(255===n[0])return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=128===n[0],!0===this.isIndefiniteForm)return this.blockLength=1,t+this.blockLength;if(this.longFormUsed=!!(128&n[0]),!1===this.longFormUsed)return this.length=n[0],this.blockLength=1,t+this.blockLength;const i=127&n[0];if(i>8)return this.error="Too big integer",-1;if(i+1>n.length)return this.error="End of input reached before message was fully decoded",-1;const o=new Uint8Array(i);for(let e=0;e<i;e++)o[e]=n[e+1];return 0===o[i-1]&&this.warnings.push("Needlessly long encoded length"),this.length=(0,s.utilFromBase)(o,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unneccesary usage of long length form"),this.blockLength=i+1,t+this.blockLength}toBER(e=!1){let t,r;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return t=new ArrayBuffer(1),!1===e&&(r=new Uint8Array(t),r[0]=128),t;if(!0===this.longFormUsed){const n=(0,s.utilToBase)(this.length,8);if(n.byteLength>127)return this.error="Too big length",new ArrayBuffer(0);if(t=new ArrayBuffer(n.byteLength+1),!0===e)return t;const i=new Uint8Array(n);r=new Uint8Array(t),r[0]=128|n.byteLength;for(let e=0;e<n.byteLength;e++)r[e+1]=i[e];return t}return t=new ArrayBuffer(1),!1===e&&(r=new Uint8Array(t),r[0]=this.length),t}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.blockName=this.constructor.blockName(),e.isIndefiniteForm=this.isIndefiniteForm,e.longFormUsed=this.longFormUsed,e.length=this.length,e}}class u extends o{constructor(e={}){super(e)}static blockName(){return"valueBlock"}fromBER(e,t,r){throw TypeError('User need to make a specific function in a class which extends "ValueBlock"')}toBER(e=!1){throw TypeError('User need to make a specific function in a class which extends "ValueBlock"')}}class h extends o{constructor(e={},t=u){super(e),"name"in e&&(this.name=e.name),"optional"in e&&(this.optional=e.optional),"primitiveSchema"in e&&(this.primitiveSchema=e.primitiveSchema),this.idBlock=new a(e),this.lenBlock=new c(e),this.valueBlock=new t(e)}static blockName(){return"BaseBlock"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}toBER(e=!1){let t;const r=this.idBlock.toBER(e),n=this.valueBlock.toBER(!0);this.lenBlock.length=n.byteLength;const i=this.lenBlock.toBER(e);let o;if(t=(0,s.utilConcatBuf)(r,i),o=!1===e?this.valueBlock.toBER(e):new ArrayBuffer(this.lenBlock.length),t=(0,s.utilConcatBuf)(t,o),!0===this.lenBlock.isIndefiniteForm){const r=new ArrayBuffer(2);if(!1===e){const e=new Uint8Array(r);e[0]=0,e[1]=0}t=(0,s.utilConcatBuf)(t,r)}return t}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.idBlock=this.idBlock.toJSON(),e.lenBlock=this.lenBlock.toJSON(),e.valueBlock=this.valueBlock.toJSON(),"name"in this&&(e.name=this.name),"optional"in this&&(e.optional=this.optional),"primitiveSchema"in this&&(e.primitiveSchema=this.primitiveSchema.toJSON()),e}}class f extends u{constructor(e={}){super(e),this.valueHex="valueHex"in e?e.valueHex.slice(0):new ArrayBuffer(0),this.isHexOnly=(0,s.getParametersValue)(e,"isHexOnly",!0)}fromBER(e,t,r){if(!1===(0,s.checkBufferParams)(this,e,t,r))return-1;const n=new Uint8Array(e,t,r);if(0===n.length)return this.warnings.push("Zero buffer length"),t;this.valueHex=new ArrayBuffer(n.length);const i=new Uint8Array(this.valueHex);for(let e=0;e<n.length;e++)i[e]=n[e];return this.blockLength=r,t+r}toBER(e=!1){return this.valueHex.slice(0)}static blockName(){return"PrimitiveValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.valueHex=(0,s.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),e.isHexOnly=this.isHexOnly,e}}class g extends h{constructor(e={}){super(e,f),this.idBlock.isConstructed=!1}static blockName(){return"PRIMITIVE"}}class d extends u{constructor(e={}){super(e),this.value=(0,s.getParametersValue)(e,"value",[]),this.isIndefiniteForm=(0,s.getParametersValue)(e,"isIndefiniteForm",!1)}fromBER(e,t,r){const n=t,i=r;if(!1===(0,s.checkBufferParams)(this,e,t,r))return-1;if(0===new Uint8Array(e,t,r).length)return this.warnings.push("Zero buffer length"),t;let o=t;for(;(!0===this.isIndefiniteForm?1:r)>0;){const t=ae(e,o,r);if(-1===t.offset)return this.error=t.result.error,this.warnings.concat(t.result.warnings),-1;if(o=t.offset,this.blockLength+=t.result.blockLength,r-=t.result.blockLength,this.value.push(t.result),!0===this.isIndefiniteForm&&t.result.constructor.blockName()===B.blockName())break}return!0===this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.blockName()===B.blockName()?this.value.pop():this.warnings.push("No EndOfContent block encoded")),this.valueBeforeDecode=e.slice(n,n+i),o}toBER(e=!1){let t=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){const n=this.value[r].toBER(e);t=(0,s.utilConcatBuf)(t,n)}return t}static blockName(){return"ConstructedValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}e.isIndefiniteForm=this.isIndefiniteForm,e.value=[];for(let t=0;t<this.value.length;t++)e.value.push(this.value[t].toJSON());return e}}class m extends h{constructor(e={}){super(e,d),this.idBlock.isConstructed=!0}static blockName(){return"CONSTRUCTED"}fromBER(e,t,r){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}}class k extends u{constructor(e={}){super(e)}fromBER(e,t,r){return t}toBER(e=!1){return new ArrayBuffer(0)}static blockName(){return"EndOfContentValueBlock"}}class B extends h{constructor(e={}){super(e,k),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}static blockName(){return"EndOfContent"}}class v extends u{constructor(e={}){super(e),this.value=(0,s.getParametersValue)(e,"value",!1),this.isHexOnly=(0,s.getParametersValue)(e,"isHexOnly",!1),"valueHex"in e?this.valueHex=e.valueHex.slice(0):(this.valueHex=new ArrayBuffer(1),!0===this.value&&(new Uint8Array(this.valueHex)[0]=255))}fromBER(e,t,r){if(!1===(0,s.checkBufferParams)(this,e,t,r))return-1;const n=new Uint8Array(e,t,r);r>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.isHexOnly=!0,this.valueHex=new ArrayBuffer(n.length);const i=new Uint8Array(this.valueHex);for(let e=0;e<n.length;e++)i[e]=n[e];return 0!==s.utilDecodeTC.call(this)?this.value=!0:this.value=!1,this.blockLength=r,t+r}toBER(e=!1){return this.valueHex}static blockName(){return"BooleanValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e.isHexOnly=this.isHexOnly,e.valueHex=(0,s.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),e}}class b extends h{constructor(e={}){super(e,v),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}static blockName(){return"Boolean"}}class y extends m{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}static blockName(){return"Sequence"}}t.T9=y;class w extends m{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}static blockName(){return"Set"}}class p extends h{constructor(e={}){super(e,o),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}static blockName(){return"Null"}fromBER(e,t,r){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=r,t+r>e.byteLength?(this.error="End of input reached before message was fully decoded (inconsistent offset and length values)",-1):t+r}toBER(e=!1){const t=new ArrayBuffer(2);if(!0===e)return t;const r=new Uint8Array(t);return r[0]=5,r[1]=0,t}}class x extends(l(d)){constructor(e={}){super(e),this.isConstructed=(0,s.getParametersValue)(e,"isConstructed",!1)}fromBER(e,t,r){let s=0;if(!0===this.isConstructed){if(this.isHexOnly=!1,s=d.prototype.fromBER.call(this,e,t,r),-1===s)return s;for(let e=0;e<this.value.length;e++){const t=this.value[e].constructor.blockName();if(t===B.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(t!==A.blockName())return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,s=super.fromBER(e,t,r),this.blockLength=r;return s}toBER(e=!1){if(!0===this.isConstructed)return d.prototype.toBER.call(this,e);let t=new ArrayBuffer(this.valueHex.byteLength);return!0===e||0===this.valueHex.byteLength||(t=this.valueHex.slice(0)),t}static blockName(){return"OctetStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.isConstructed=this.isConstructed,e.isHexOnly=this.isHexOnly,e.valueHex=(0,s.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),e}}class A extends h{constructor(e={}){super(e,x),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(e,t,r){return this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,0===r?(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),t):super.fromBER(e,t,r)}static blockName(){return"OctetString"}isEqual(e){return e instanceof A!=0&&JSON.stringify(this)===JSON.stringify(e)}}t.fi=A;class N extends(l(d)){constructor(e={}){super(e),this.unusedBits=(0,s.getParametersValue)(e,"unusedBits",0),this.isConstructed=(0,s.getParametersValue)(e,"isConstructed",!1),this.blockLength=this.valueHex.byteLength}fromBER(e,t,r){if(0===r)return t;let n=-1;if(!0===this.isConstructed){if(n=d.prototype.fromBER.call(this,e,t,r),-1===n)return n;for(let e=0;e<this.value.length;e++){const t=this.value[e].constructor.blockName();if(t===B.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(t!==H.blockName())return this.error="BIT STRING may consists of BIT STRINGs only",-1;if(this.unusedBits>0&&this.value[e].valueBlock.unusedBits>0)return this.error='Usign of "unused bits" inside constructive BIT STRING allowed for least one only',-1;if(this.unusedBits=this.value[e].valueBlock.unusedBits,this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1}return n}if(!1===(0,s.checkBufferParams)(this,e,t,r))return-1;const i=new Uint8Array(e,t,r);if(this.unusedBits=i[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;this.valueHex=new ArrayBuffer(i.length-1);const o=new Uint8Array(this.valueHex);for(let e=0;e<r-1;e++)o[e]=i[e+1];return this.blockLength=i.length,t+r}toBER(e=!1){if(!0===this.isConstructed)return d.prototype.toBER.call(this,e);if(!0===e)return new ArrayBuffer(this.valueHex.byteLength+1);if(0===this.valueHex.byteLength)return new ArrayBuffer(0);const t=new Uint8Array(this.valueHex),r=new ArrayBuffer(this.valueHex.byteLength+1),s=new Uint8Array(r);s[0]=this.unusedBits;for(let e=0;e<this.valueHex.byteLength;e++)s[e+1]=t[e];return r}static blockName(){return"BitStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.unusedBits=this.unusedBits,e.isConstructed=this.isConstructed,e.isHexOnly=this.isHexOnly,e.valueHex=(0,s.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),e}}class H extends h{constructor(e={}){super(e,N),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}static blockName(){return"BitString"}fromBER(e,t,r){return 0===r?t:(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(e,t,r))}isEqual(e){return e instanceof H!=0&&JSON.stringify(this)===JSON.stringify(e)}}t._K=H;class S extends(l(u)){constructor(e={}){super(e),"value"in e&&(this.valueDec=e.value)}set valueHex(e){this._valueHex=e.slice(0),e.byteLength>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,e.byteLength>0&&(this._valueDec=s.utilDecodeTC.call(this)))}get valueHex(){return this._valueHex}set valueDec(e){this._valueDec=e,this.isHexOnly=!1,this._valueHex=(0,s.utilEncodeTC)(e)}get valueDec(){return this._valueDec}fromDER(e,t,r,s=0){const n=this.fromBER(e,t,r);if(-1===n)return n;const i=new Uint8Array(this._valueHex);if(0===i[0]&&0!=(128&i[1])){const e=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(e).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=e.slice(0)}else if(0!==s&&this._valueHex.byteLength<s){s-this._valueHex.byteLength>1&&(s=this._valueHex.byteLength+1);const e=new ArrayBuffer(s);new Uint8Array(e).set(i,s-this._valueHex.byteLength),this._valueHex=e.slice(0)}return n}toDER(e=!1){const t=new Uint8Array(this._valueHex);switch(!0){case 0!=(128&t[0]):{const e=new ArrayBuffer(this._valueHex.byteLength+1),r=new Uint8Array(e);r[0]=0,r.set(t,1),this._valueHex=e.slice(0)}break;case 0===t[0]&&0==(128&t[1]):{const e=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(e).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=e.slice(0)}}return this.toBER(e)}fromBER(e,t,r){const s=super.fromBER(e,t,r);return-1===s?s:(this.blockLength=r,t+r)}toBER(e=!1){return this.valueHex.slice(0)}static blockName(){return"IntegerValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.valueDec=this.valueDec,e}toString(){function e(e,t){const r=new Uint8Array([0]);let n=new Uint8Array(e),i=new Uint8Array(t),o=n.slice(0);const l=o.length-1;let a=i.slice(0);const c=a.length-1;let u=0,h=0;for(let e=c<l?l:c;e>=0;e--,h++){switch(!0){case h<a.length:u=o[l-h]+a[c-h]+r[0];break;default:u=o[l-h]+r[0]}switch(r[0]=u/10,!0){case h>=o.length:o=(0,s.utilConcatView)(new Uint8Array([u%10]),o);break;default:o[l-h]=u%10}}return r[0]>0&&(o=(0,s.utilConcatView)(r,o)),o.slice(0)}function t(e){if(e>=n.length)for(let t=n.length;t<=e;t++){const e=new Uint8Array([0]);let r=n[t-1].slice(0);for(let t=r.length-1;t>=0;t--){const s=new Uint8Array([(r[t]<<1)+e[0]]);e[0]=s[0]/10,r[t]=s[0]%10}e[0]>0&&(r=(0,s.utilConcatView)(e,r)),n.push(r)}return n[e]}function r(e,t){let r=0,s=new Uint8Array(e),n=new Uint8Array(t),i=s.slice(0);const o=i.length-1;let l=n.slice(0);const a=l.length-1;let c,u=0;for(let e=a;e>=0;e--,u++)switch(c=i[o-u]-l[a-u]-r,!0){case c<0:r=1,i[o-u]=c+10;break;default:r=0,i[o-u]=c}if(r>0)for(let e=o-a+1;e>=0;e--,u++){if(c=i[o-u]-r,!(c<0)){r=0,i[o-u]=c;break}r=1,i[o-u]=c+10}return i.slice()}const o=8*this._valueHex.byteLength-1;let l,a=new Uint8Array(8*this._valueHex.byteLength/3),c=0;const u=new Uint8Array(this._valueHex);let h="",f=!1;for(let s=this._valueHex.byteLength-1;s>=0;s--){l=u[s];for(let s=0;s<8;s++){if(1==(1&l))switch(c){case o:a=r(t(c),a),h="-";break;default:a=e(a,t(c))}c++,l>>=1}}for(let e=0;e<a.length;e++)a[e]&&(f=!0),f&&(h+=i.charAt(a[e]));return!1===f&&(h+=i.charAt(0)),h}}class L extends h{constructor(e={}){super(e,S),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}static blockName(){return"Integer"}isEqual(e){return e instanceof L?this.valueBlock.isHexOnly&&e.valueBlock.isHexOnly?(0,s.isEqualBuffer)(this.valueBlock.valueHex,e.valueBlock.valueHex):this.valueBlock.isHexOnly===e.valueBlock.isHexOnly&&this.valueBlock.valueDec===e.valueBlock.valueDec:e instanceof ArrayBuffer&&(0,s.isEqualBuffer)(this.valueBlock.valueHex,e)}convertToDER(){const e=new L({valueHex:this.valueBlock.valueHex});return e.valueBlock.toDER(),e}convertFromDER(){const e=this.valueBlock.valueHex.byteLength%2?this.valueBlock.valueHex.byteLength+1:this.valueBlock.valueHex.byteLength,t=new L({valueHex:this.valueBlock.valueHex});return t.valueBlock.fromDER(t.valueBlock.valueHex,0,t.valueBlock.valueHex.byteLength,e),t}}t.z8=L;class C extends L{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}static blockName(){return"Enumerated"}}class O extends(l(o)){constructor(e={}){super(e),this.valueDec=(0,s.getParametersValue)(e,"valueDec",-1),this.isFirstSid=(0,s.getParametersValue)(e,"isFirstSid",!1)}static blockName(){return"sidBlock"}fromBER(e,t,r){if(0===r)return t;if(!1===(0,s.checkBufferParams)(this,e,t,r))return-1;const n=new Uint8Array(e,t,r);this.valueHex=new ArrayBuffer(r);let i=new Uint8Array(this.valueHex);for(let e=0;e<r&&(i[e]=127&n[e],this.blockLength++,0!=(128&n[e]));e++);const o=new ArrayBuffer(this.blockLength),l=new Uint8Array(o);for(let e=0;e<this.blockLength;e++)l[e]=i[e];return this.valueHex=o.slice(0),i=new Uint8Array(this.valueHex),0!=(128&n[this.blockLength-1])?(this.error="End of input reached before message was fully decoded",-1):(0===i[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=(0,s.utilFromBase)(i,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}toBER(e=!1){let t,r;if(this.isHexOnly){if(!0===e)return new ArrayBuffer(this.valueHex.byteLength);const s=new Uint8Array(this.valueHex);t=new ArrayBuffer(this.blockLength),r=new Uint8Array(t);for(let e=0;e<this.blockLength-1;e++)r[e]=128|s[e];return r[this.blockLength-1]=s[this.blockLength-1],t}const n=(0,s.utilToBase)(this.valueDec,7);if(0===n.byteLength)return this.error="Error during encoding SID value",new ArrayBuffer(0);if(t=new ArrayBuffer(n.byteLength),!1===e){const e=new Uint8Array(n);r=new Uint8Array(t);for(let t=0;t<n.byteLength-1;t++)r[t]=128|e[t];r[n.byteLength-1]=e[n.byteLength-1]}return t}toString(){let e="";if(!0===this.isHexOnly)e=(0,s.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength);else if(this.isFirstSid){let t=this.valueDec;this.valueDec<=39?e="0.":this.valueDec<=79?(e="1.",t-=40):(e="2.",t-=80),e+=t.toString()}else e=this.valueDec.toString();return e}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.valueDec=this.valueDec,e.isFirstSid=this.isFirstSid,e}}class U extends u{constructor(e={}){super(e),this.fromString((0,s.getParametersValue)(e,"value",""))}fromBER(e,t,r){let s=t;for(;r>0;){const t=new O;if(s=t.fromBER(e,s,r),-1===s)return this.blockLength=0,this.error=t.error,s;0===this.value.length&&(t.isFirstSid=!0),this.blockLength+=t.blockLength,r-=t.blockLength,this.value.push(t)}return s}toBER(e=!1){let t=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){const n=this.value[r].toBER(e);if(0===n.byteLength)return this.error=this.value[r].error,new ArrayBuffer(0);t=(0,s.utilConcatBuf)(t,n)}return t}fromString(e){this.value=[];let t=0,r=0,s="",n=!1;do{if(r=e.indexOf(".",t),s=-1===r?e.substr(t):e.substr(t,r-t),t=r+1,n){const e=this.value[0];let t=0;switch(e.valueDec){case 0:break;case 1:t=40;break;case 2:t=80;break;default:return this.value=[],!1}const r=parseInt(s,10);if(isNaN(r))return!0;e.valueDec=r+t,n=!1}else{const e=new O;if(e.valueDec=parseInt(s,10),isNaN(e.valueDec))return!0;0===this.value.length&&(e.isFirstSid=!0,n=!0),this.value.push(e)}}while(-1!==r);return!0}toString(){let e="",t=!1;for(let r=0;r<this.value.length;r++){t=this.value[r].isHexOnly;let s=this.value[r].toString();0!==r&&(e=`${e}.`),t?(s=`{${s}}`,this.value[r].isFirstSid?e=`2.{${s} - 80}`:e+=s):e+=s}return e}static blockName(){return"ObjectIdentifierValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}e.value=this.toString(),e.sidArray=[];for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}class E extends h{constructor(e={}){super(e,U),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}static blockName(){return"ObjectIdentifier"}}t.rP=E;class I extends(l(o)){constructor(e={}){super(e),this.isHexOnly=!0,this.value=""}static blockName(){return"Utf8StringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class T extends h{constructor(e={}){super(e,I),"value"in e&&this.fromString(e.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}static blockName(){return"Utf8String"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(e));try{this.valueBlock.value=decodeURIComponent(escape(this.valueBlock.value))}catch(e){this.warnings.push(`Error during "decodeURIComponent": ${e}, using raw string`)}}fromString(e){const t=unescape(encodeURIComponent(e)),r=t.length;this.valueBlock.valueHex=new ArrayBuffer(r);const s=new Uint8Array(this.valueBlock.valueHex);for(let e=0;e<r;e++)s[e]=t.charCodeAt(e);this.valueBlock.value=e}}class R extends(l(o)){constructor(e={}){super(e),this.valueDec=(0,s.getParametersValue)(e,"valueDec",-1)}static blockName(){return"relativeSidBlock"}fromBER(e,t,r){if(0===r)return t;if(!1===(0,s.checkBufferParams)(this,e,t,r))return-1;const n=new Uint8Array(e,t,r);this.valueHex=new ArrayBuffer(r);let i=new Uint8Array(this.valueHex);for(let e=0;e<r&&(i[e]=127&n[e],this.blockLength++,0!=(128&n[e]));e++);const o=new ArrayBuffer(this.blockLength),l=new Uint8Array(o);for(let e=0;e<this.blockLength;e++)l[e]=i[e];return this.valueHex=o.slice(0),i=new Uint8Array(this.valueHex),0!=(128&n[this.blockLength-1])?(this.error="End of input reached before message was fully decoded",-1):(0===i[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=(0,s.utilFromBase)(i,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}toBER(e=!1){let t,r;if(this.isHexOnly){if(!0===e)return new ArrayBuffer(this.valueHex.byteLength);const s=new Uint8Array(this.valueHex);t=new ArrayBuffer(this.blockLength),r=new Uint8Array(t);for(let e=0;e<this.blockLength-1;e++)r[e]=128|s[e];return r[this.blockLength-1]=s[this.blockLength-1],t}const n=(0,s.utilToBase)(this.valueDec,7);if(0===n.byteLength)return this.error="Error during encoding SID value",new ArrayBuffer(0);if(t=new ArrayBuffer(n.byteLength),!1===e){const e=new Uint8Array(n);r=new Uint8Array(t);for(let t=0;t<n.byteLength-1;t++)r[t]=128|e[t];r[n.byteLength-1]=e[n.byteLength-1]}return t}toString(){let e="";return e=!0===this.isHexOnly?(0,s.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength):this.valueDec.toString(),e}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.valueDec=this.valueDec,e}}class P extends u{constructor(e={}){super(e),this.fromString((0,s.getParametersValue)(e,"value",""))}fromBER(e,t,r){let s=t;for(;r>0;){const t=new R;if(s=t.fromBER(e,s,r),-1===s)return this.blockLength=0,this.error=t.error,s;this.blockLength+=t.blockLength,r-=t.blockLength,this.value.push(t)}return s}toBER(e=!1){let t=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){const n=this.value[r].toBER(e);if(0===n.byteLength)return this.error=this.value[r].error,new ArrayBuffer(0);t=(0,s.utilConcatBuf)(t,n)}return t}fromString(e){this.value=[];let t=0,r=0,s="";do{r=e.indexOf(".",t),s=-1===r?e.substr(t):e.substr(t,r-t),t=r+1;const n=new R;if(n.valueDec=parseInt(s,10),isNaN(n.valueDec))return!0;this.value.push(n)}while(-1!==r);return!0}toString(){let e="",t=!1;for(let r=0;r<this.value.length;r++){t=this.value[r].isHexOnly;let s=this.value[r].toString();0!==r&&(e=`${e}.`),t?(s=`{${s}}`,e+=s):e+=s}return e}static blockName(){return"RelativeObjectIdentifierValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}e.value=this.toString(),e.sidArray=[];for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}class D extends h{constructor(e={}){super(e,P),this.idBlock.tagClass=1,this.idBlock.tagNumber=13}static blockName(){return"RelativeObjectIdentifier"}}class V extends(l(o)){constructor(e={}){super(e),this.isHexOnly=!0,this.value=""}static blockName(){return"BmpStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class F extends h{constructor(e={}){super(e,V),"value"in e&&this.fromString(e.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}static blockName(){return"BmpString"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){const t=e.slice(0),r=new Uint8Array(t);for(let e=0;e<r.length;e+=2){const t=r[e];r[e]=r[e+1],r[e+1]=t}this.valueBlock.value=String.fromCharCode.apply(null,new Uint16Array(t))}fromString(e){const t=e.length;this.valueBlock.valueHex=new ArrayBuffer(2*t);const r=new Uint8Array(this.valueBlock.valueHex);for(let n=0;n<t;n++){const t=(0,s.utilToBase)(e.charCodeAt(n),8),i=new Uint8Array(t);if(i.length>2)continue;const o=2-i.length;for(let e=i.length-1;e>=0;e--)r[2*n+e+o]=i[e]}this.valueBlock.value=e}}class J extends(l(o)){constructor(e={}){super(e),this.isHexOnly=!0,this.value=""}static blockName(){return"UniversalStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class _ extends h{constructor(e={}){super(e,J),"value"in e&&this.fromString(e.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}static blockName(){return"UniversalString"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){const t=e.slice(0),r=new Uint8Array(t);for(let e=0;e<r.length;e+=4)r[e]=r[e+3],r[e+1]=r[e+2],r[e+2]=0,r[e+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(t))}fromString(e){const t=e.length;this.valueBlock.valueHex=new ArrayBuffer(4*t);const r=new Uint8Array(this.valueBlock.valueHex);for(let n=0;n<t;n++){const t=(0,s.utilToBase)(e.charCodeAt(n),8),i=new Uint8Array(t);if(i.length>4)continue;const o=4-i.length;for(let e=i.length-1;e>=0;e--)r[4*n+e+o]=i[e]}this.valueBlock.value=e}}class j extends(l(o)){constructor(e={}){super(e),this.value="",this.isHexOnly=!0}static blockName(){return"SimpleStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class M extends h{constructor(e={}){super(e,j),"value"in e&&this.fromString(e.value)}static blockName(){return"SIMPLESTRING"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(e))}fromString(e){const t=e.length;this.valueBlock.valueHex=new ArrayBuffer(t);const r=new Uint8Array(this.valueBlock.valueHex);for(let s=0;s<t;s++)r[s]=e.charCodeAt(s);this.valueBlock.value=e}}class W extends M{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}static blockName(){return"NumericString"}}class $ extends M{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}static blockName(){return"PrintableString"}}class K extends M{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}static blockName(){return"TeletexString"}}class G extends M{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}static blockName(){return"VideotexString"}}class z extends M{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}static blockName(){return"IA5String"}}class Z extends M{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}static blockName(){return"GraphicString"}}class q extends M{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}static blockName(){return"VisibleString"}}class Y extends M{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}static blockName(){return"GeneralString"}}class Q extends M{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}static blockName(){return"CharacterString"}}class X extends q{constructor(e={}){if(super(e),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,"value"in e){this.fromString(e.value),this.valueBlock.valueHex=new ArrayBuffer(e.value.length);const t=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<e.value.length;r++)t[r]=e.value.charCodeAt(r)}"valueDate"in e&&(this.fromDate(e.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,new Uint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(e){const t=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/gi.exec(e);if(null===t)return void(this.error="Wrong input string for convertion");const r=parseInt(t[1],10);this.year=r>=50?1900+r:2e3+r,this.month=parseInt(t[2],10),this.day=parseInt(t[3],10),this.hour=parseInt(t[4],10),this.minute=parseInt(t[5],10),this.second=parseInt(t[6],10)}toString(){const e=new Array(7);return e[0]=(0,s.padNumber)(this.year<2e3?this.year-1900:this.year-2e3,2),e[1]=(0,s.padNumber)(this.month,2),e[2]=(0,s.padNumber)(this.day,2),e[3]=(0,s.padNumber)(this.hour,2),e[4]=(0,s.padNumber)(this.minute,2),e[5]=(0,s.padNumber)(this.second,2),e[6]="Z",e.join("")}static blockName(){return"UTCTime"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.year=this.year,e.month=this.month,e.day=this.day,e.hour=this.hour,e.minute=this.minute,e.second=this.second,e}}class ee extends q{constructor(e={}){if(super(e),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,this.millisecond=0,"value"in e){this.fromString(e.value),this.valueBlock.valueHex=new ArrayBuffer(e.value.length);const t=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<e.value.length;r++)t[r]=e.value.charCodeAt(r)}"valueDate"in e&&(this.fromDate(e.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,new Uint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds(),this.millisecond=e.getUTCMilliseconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond))}fromString(e){let t,r=!1,s="",n="",i=0,o=0,l=0;if("Z"===e[e.length-1])s=e.substr(0,e.length-1),r=!0;else{const t=new Number(e[e.length-1]);if(isNaN(t.valueOf()))throw new Error("Wrong input string for convertion");s=e}if(r){if(-1!==s.indexOf("+"))throw new Error("Wrong input string for convertion");if(-1!==s.indexOf("-"))throw new Error("Wrong input string for convertion")}else{let e=1,t=s.indexOf("+"),r="";if(-1===t&&(t=s.indexOf("-"),e=-1),-1!==t){if(r=s.substr(t+1),s=s.substr(0,t),2!==r.length&&4!==r.length)throw new Error("Wrong input string for convertion");let n=new Number(r.substr(0,2));if(isNaN(n.valueOf()))throw new Error("Wrong input string for convertion");if(o=e*n,4===r.length){if(n=new Number(r.substr(2,2)),isNaN(n.valueOf()))throw new Error("Wrong input string for convertion");l=e*n}}}let a=s.indexOf(".");if(-1===a&&(a=s.indexOf(",")),-1!==a){const e=new Number(`0${s.substr(a)}`);if(isNaN(e.valueOf()))throw new Error("Wrong input string for convertion");i=e.valueOf(),n=s.substr(0,a)}else n=s;switch(!0){case 8===n.length:if(t=/(\d{4})(\d{2})(\d{2})/gi,-1!==a)throw new Error("Wrong input string for convertion");break;case 10===n.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})/gi,-1!==a){let e=60*i;this.minute=Math.floor(e),e=60*(e-this.minute),this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 12===n.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==a){let e=60*i;this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 14===n.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==a){const e=1e3*i;this.millisecond=Math.floor(e)}break;default:throw new Error("Wrong input string for convertion")}const c=t.exec(n);if(null===c)throw new Error("Wrong input string for convertion");for(let e=1;e<c.length;e++)switch(e){case 1:this.year=parseInt(c[e],10);break;case 2:this.month=parseInt(c[e],10);break;case 3:this.day=parseInt(c[e],10);break;case 4:this.hour=parseInt(c[e],10)+o;break;case 5:this.minute=parseInt(c[e],10)+l;break;case 6:this.second=parseInt(c[e],10);break;default:throw new Error("Wrong input string for convertion")}if(!1===r){const e=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=e.getUTCFullYear(),this.month=e.getUTCMonth(),this.day=e.getUTCDay(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds(),this.millisecond=e.getUTCMilliseconds()}}toString(){const e=[];return e.push((0,s.padNumber)(this.year,4)),e.push((0,s.padNumber)(this.month,2)),e.push((0,s.padNumber)(this.day,2)),e.push((0,s.padNumber)(this.hour,2)),e.push((0,s.padNumber)(this.minute,2)),e.push((0,s.padNumber)(this.second,2)),0!==this.millisecond&&(e.push("."),e.push((0,s.padNumber)(this.millisecond,3))),e.push("Z"),e.join("")}static blockName(){return"GeneralizedTime"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.year=this.year,e.month=this.month,e.day=this.day,e.hour=this.hour,e.minute=this.minute,e.second=this.second,e.millisecond=this.millisecond,e}}class te extends T{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}static blockName(){return"DATE"}}class re extends T{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}static blockName(){return"TimeOfDay"}}class se extends T{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}static blockName(){return"DateTime"}}class ne extends T{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}static blockName(){return"Duration"}}class ie extends T{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}static blockName(){return"TIME"}}class oe{constructor(e={}){this.name=(0,s.getParametersValue)(e,"name",""),this.optional=(0,s.getParametersValue)(e,"optional",!1)}}t.IK=oe;class le{constructor(e={}){this.name=(0,s.getParametersValue)(e,"name",""),this.optional=(0,s.getParametersValue)(e,"optional",!1),this.value=(0,s.getParametersValue)(e,"value",new oe),this.local=(0,s.getParametersValue)(e,"local",!1)}}function ae(e,t,r){const n=t;let i=new h({},Object);const l=new o;if(!1===(0,s.checkBufferParams)(l,e,t,r))return i.error=l.error,{offset:-1,result:i};if(0===new Uint8Array(e,t,r).length)return this.error="Zero buffer length",{offset:-1,result:i};let a=i.idBlock.fromBER(e,t,r);if(i.warnings.concat(i.idBlock.warnings),-1===a)return i.error=i.idBlock.error,{offset:-1,result:i};if(t=a,r-=i.idBlock.blockLength,a=i.lenBlock.fromBER(e,t,r),i.warnings.concat(i.lenBlock.warnings),-1===a)return i.error=i.lenBlock.error,{offset:-1,result:i};if(t=a,r-=i.lenBlock.blockLength,!1===i.idBlock.isConstructed&&!0===i.lenBlock.isIndefiniteForm)return i.error="Indefinite length form used for primitive encoding form",{offset:-1,result:i};let c=h;switch(i.idBlock.tagClass){case 1:if(i.idBlock.tagNumber>=37&&!1===i.idBlock.isHexOnly)return i.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:i};switch(i.idBlock.tagNumber){case 0:if(!0===i.idBlock.isConstructed&&i.lenBlock.length>0)return i.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:i};c=B;break;case 1:c=b;break;case 2:c=L;break;case 3:c=H;break;case 4:c=A;break;case 5:c=p;break;case 6:c=E;break;case 10:c=C;break;case 12:c=T;break;case 13:c=D;break;case 14:c=ie;break;case 15:return i.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:i};case 16:c=y;break;case 17:c=w;break;case 18:c=W;break;case 19:c=$;break;case 20:c=K;break;case 21:c=G;break;case 22:c=z;break;case 23:c=X;break;case 24:c=ee;break;case 25:c=Z;break;case 26:c=q;break;case 27:c=Y;break;case 28:c=_;break;case 29:c=Q;break;case 30:c=F;break;case 31:c=te;break;case 32:c=re;break;case 33:c=se;break;case 34:c=ne;break;default:{let s;s=!0===i.idBlock.isConstructed?new m:new g,s.idBlock=i.idBlock,s.lenBlock=i.lenBlock,s.warnings=i.warnings,i=s,a=i.fromBER(e,t,r)}}break;case 2:case 3:case 4:default:c=!0===i.idBlock.isConstructed?m:g}return i=function(e,t){if(e instanceof t)return e;const r=new t;return r.idBlock=e.idBlock,r.lenBlock=e.lenBlock,r.warnings=e.warnings,r.valueBeforeDecode=e.valueBeforeDecode.slice(0),r}(i,c),a=i.fromBER(e,t,!0===i.lenBlock.isIndefiniteForm?r:i.lenBlock.length),i.valueBeforeDecode=e.slice(n,n+i.blockLength),{offset:a,result:i}}function ce(e){if(0===e.byteLength){const e=new h({},Object);return e.error="Input buffer has zero length",{offset:-1,result:e}}return ae(e,0,e.byteLength)}},447:(e,t,r)=>{function s(e){return new Date(e.getTime()+6e4*e.getTimezoneOffset())}function n(e,t,r){return e instanceof Object==0?r:t in e?e[t]:r}function i(e,t=0,r=e.byteLength-t,s=!1){let n="";for(const i of new Uint8Array(e,t,r)){const e=i.toString(16).toUpperCase();1===e.length&&(n+="0"),n+=e,s&&(n+=" ")}return n.trim()}function o(e,t,r,s){return t instanceof ArrayBuffer==0?(e.error='Wrong parameter: inputBuffer must be "ArrayBuffer"',!1):0===t.byteLength?(e.error="Wrong parameter: inputBuffer has zero length",!1):r<0?(e.error="Wrong parameter: inputOffset less than zero",!1):s<0?(e.error="Wrong parameter: inputLength less than zero",!1):!(t.byteLength-r-s<0&&(e.error="End of input reached before message was fully decoded (inconsistent offset and length values)",1))}function l(e,t){let r=0;if(1===e.length)return e[0];for(let s=e.length-1;s>=0;s--)r+=e[e.length-1-s]*Math.pow(2,t*s);return r}function a(e,t,r=-1){const s=r;let n=e,i=0,o=Math.pow(2,t);for(let r=1;r<8;r++){if(e<o){let e;if(s<0)e=new ArrayBuffer(r),i=r;else{if(s<r)return new ArrayBuffer(0);e=new ArrayBuffer(s),i=s}const o=new Uint8Array(e);for(let e=r-1;e>=0;e--){const r=Math.pow(2,e*t);o[i-e-1]=Math.floor(n/r),n-=o[i-e-1]*r}return e}o*=Math.pow(2,t)}return new ArrayBuffer(0)}function c(...e){let t=0,r=0;for(const r of e)t+=r.byteLength;const s=new ArrayBuffer(t),n=new Uint8Array(s);for(const t of e)n.set(new Uint8Array(t),r),r+=t.byteLength;return s}function u(...e){let t=0,r=0;for(const r of e)t+=r.length;const s=new ArrayBuffer(t),n=new Uint8Array(s);for(const t of e)n.set(t,r),r+=t.length;return n}function h(){const e=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){const t=255===e[0]&&128&e[1],r=0===e[0]&&0==(128&e[1]);(t||r)&&this.warnings.push("Needlessly long format")}const t=new ArrayBuffer(this.valueHex.byteLength),r=new Uint8Array(t);for(let e=0;e<this.valueHex.byteLength;e++)r[e]=0;r[0]=128&e[0];const s=l(r,8),n=new ArrayBuffer(this.valueHex.byteLength),i=new Uint8Array(n);for(let t=0;t<this.valueHex.byteLength;t++)i[t]=e[t];return i[0]&=127,l(i,8)-s}function f(e){const t=e<0?-1*e:e;let r=128;for(let s=1;s<8;s++){if(t<=r){if(e<0){const e=a(r-t,8,s);return new Uint8Array(e)[0]|=128,e}let n=a(t,8,s),i=new Uint8Array(n);if(128&i[0]){const e=n.slice(0),t=new Uint8Array(e);n=new ArrayBuffer(n.byteLength+1),i=new Uint8Array(n);for(let r=0;r<e.byteLength;r++)i[r+1]=t[r];i[0]=0}return n}r*=Math.pow(2,8)}return new ArrayBuffer(0)}function g(e,t){if(e.byteLength!==t.byteLength)return!1;const r=new Uint8Array(e),s=new Uint8Array(t);for(let e=0;e<r.length;e++)if(r[e]!==s[e])return!1;return!0}function d(e,t){const r=e.toString(10);if(t<r.length)return"";const s=t-r.length,n=new Array(s);for(let e=0;e<s;e++)n[e]="0";return n.join("").concat(r)}r.r(t),r.d(t,{getUTCDate:()=>s,getParametersValue:()=>n,bufferToHexCodes:()=>i,checkBufferParams:()=>o,utilFromBase:()=>l,utilToBase:()=>a,utilConcatBuf:()=>c,utilConcatView:()=>u,utilDecodeTC:()=>h,utilEncodeTC:()=>f,isEqualBuffer:()=>g,padNumber:()=>d,toBase64:()=>B,fromBase64:()=>v,arrayBufferToString:()=>b,stringToArrayBuffer:()=>y,nearestPowerOf2:()=>p,clearProps:()=>x});const m="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",k="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=";function B(e,t=!1,r=!1,s=!1){let n=0,i=0,o=0,l="";const a=t?k:m;if(s){let t=0;for(let r=0;r<e.length;r++)if(0!==e.charCodeAt(r)){t=r;break}e=e.slice(t)}for(;n<e.length;){const t=e.charCodeAt(n++);n>=e.length&&(i=1);const s=e.charCodeAt(n++);n>=e.length&&(o=1);const c=e.charCodeAt(n++),u=t>>2,h=(3&t)<<4|s>>4;let f=(15&s)<<2|c>>6,g=63&c;1===i?f=g=64:1===o&&(g=64),l+=r?64===f?`${a.charAt(u)}${a.charAt(h)}`:64===g?`${a.charAt(u)}${a.charAt(h)}${a.charAt(f)}`:`${a.charAt(u)}${a.charAt(h)}${a.charAt(f)}${a.charAt(g)}`:`${a.charAt(u)}${a.charAt(h)}${a.charAt(f)}${a.charAt(g)}`}return l}function v(e,t=!1,r=!1){const s=t?k:m;function n(e){for(let t=0;t<64;t++)if(s.charAt(t)===e)return t;return 64}function i(e){return 64===e?0:e}let o=0,l="";for(;o<e.length;){const t=n(e.charAt(o++)),r=o>=e.length?0:n(e.charAt(o++)),s=o>=e.length?0:n(e.charAt(o++)),a=o>=e.length?0:n(e.charAt(o++)),c=i(t)<<2|i(r)>>4,u=(15&i(r))<<4|i(s)>>2,h=(3&i(s))<<6|i(a);l+=String.fromCharCode(c),64!==s&&(l+=String.fromCharCode(u)),64!==a&&(l+=String.fromCharCode(h))}if(r){let e=-1;for(let t=l.length-1;t>=0;t--)if(0!==l.charCodeAt(t)){e=t;break}l=-1!==e?l.slice(0,e+1):""}return l}function b(e){let t="";const r=new Uint8Array(e);for(const e of r)t+=String.fromCharCode(e);return t}function y(e){const t=e.length,r=new ArrayBuffer(t),s=new Uint8Array(r);for(let r=0;r<t;r++)s[r]=e.charCodeAt(r);return r}const w=Math.log(2);function p(e){const t=Math.log(e)/w,r=Math.floor(t),s=Math.round(t);return r===s?r:s}function x(e,t){for(const r of t)delete e[r]}}},t={};function r(s){if(t[s])return t[s].exports;var n=t[s]={exports:{}};return e[s](n,n.exports,r),n.exports}r.d=(e,t)=>{for(var s in t)r.o(t,s)&&!r.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:t[s]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{var e=r(360);function t(e,t,r){return e instanceof Object==0?r:t in e?e[t]:r}function s(e,t=0,r=e.byteLength-t,s=!1){let n="";for(const i of new Uint8Array(e,t,r)){const e=i.toString(16).toUpperCase();1===e.length&&(n+="0"),n+=e,s&&(n+=" ")}return n.trim()}function n(e,t){for(const r of t)delete e[r]}Math.log(2);class i{constructor(e={}){if("string"==typeof e)throw new TypeError("Unimplemented: Not accepting string yet.");if(e instanceof ArrayBuffer){const t=fromBER(e);this.fromSchema(t.result)}else this.algorithmId=t(e,"algorithmId"),"algorithmParams"in e&&(this.algorithmParams=t(e,"algorithmParams",i.defaultValues("algorithmParams")))}static defaultValues(t){switch(t){case"algorithmParams":return new e.IK;default:throw new Error(`Invalid member name for AlgorithmIdentifier class: ${t}`)}}static compareWithDefault(e,t){switch(e){case"algorithmId":return""===t;case"algorithmParams":return t instanceof asn1js.Any;default:throw new Error(`Invalid member name for AlgorithmIdentifier class: ${e}`)}}static schema(r={}){const s=t(r,"names",{});return new e.T9({name:s.blockName||"",optional:s.optional||!1,value:[new e.rP({name:s.algorithmIdentifier||"algorithm"}),new e.IK({name:s.algorithmParams||"parameters",optional:!0})]})}fromSchema(t){n(t,["algorithm","params"]);const r=(0,e.eN)(t,t,i.schema({names:{algorithmIdentifier:"algorithm",algorithmParams:"params"}}));if(!1===r.verified)throw new Error("Object's schema was not verified against input data for AlgorithmIdentifier");this.algorithmId=r.result.algorithm.valueBlock.toString(),"params"in r.result&&(this.algorithmParams=r.result.params)}toSchema(){const t=[];return t.push(new e.rP({value:this.algorithmId})),"algorithmParams"in this&&this.algorithmParams instanceof asn1js.Any==0&&t.push(this.algorithmParams),new e.T9({value:t})}toJSON(){const e={algorithmId:this.algorithmId};return"algorithmParams"in this&&this.algorithmParams instanceof asn1js.Any==0&&(e.algorithmParams=this.algorithmParams.toJSON()),e}isEqual(e){return e instanceof i!=0&&this.algorithmId===e.algorithmId&&("algorithmParams"in this?"algorithmParams"in e&&JSON.stringify(this.algorithmParams)===JSON.stringify(e.algorithmParams):!("algorithmParams"in e))}}class o{constructor(r={}){if("string"==typeof r)throw new TypeError("Not accepting string. For base64, convert to ArrayBuffer.");if(r instanceof ArrayBuffer){const t=(0,e.sc)(r);this.fromSchema(t.result)}else this.signatureAlgorithm=t(r,"signatureAlgorithm"),this.publicKey=t(r,"publicKey")}static schema(r={}){const s=t(r,"names",{});return new e.T9({name:s.blockName||"",optional:!0,value:[i.schema(s.signatureAlgorithm||{names:{blockName:"signatureAlgorithm"}}),new e._K({name:"publicKey"})]})}fromSchema(t){if(n(t,["signatureAlgorithm","publicKey"]),!1===(0,e.eN)(t,t,o.schema({names:{signatureAlgorithm:"signatureAlgorithm",publicKey:"publicKey"}})).verified)throw new Error("Object's schema was not verified against input data for AlgorithmIdentifier")}}class l{constructor(r={}){if("string"==typeof r)throw new TypeError("Unimplemented: Not accepting string yet.");if(r instanceof ArrayBuffer){const t=(0,e.sc)(r);this.fromSchema(t.result)}else this.devconId=t(r,"devconId"),this.ticketId=t(r,"ticketId"),this.ticketClass=t(r,"ticketClass")}static schema(r={}){const s=t(r,"names",{});return new e.T9({name:s.blockName||"ticket",value:[new e.z8({name:s.devconId||"devconId"}),new e.z8({name:s.ticketId||"ticketId"}),new e.z8({name:s.ticketClass||"ticketClass"})]})}fromSchema(t){n(t,["devconId","ticketId","ticketClass"]);const r=(0,e.eN)(t,t,l.schema());if(!1===r.verified)throw new Error("Object's schema was not verified against input data for DevconTicket");if("devconId"in r.result){const e=r.result.devconId.valueBlock._valueHex;this.devconId=BigInt("0x"+s(e))}if("ticketId"in r.result){const e=r.result.ticketId.valueBlock._valueHex;this.ticketId=BigInt("0x"+s(e))}if("ticketClass"in r.result){const e=r.result.ticketClass.valueBlock._valueHex;this.ticketClass=BigInt("0x"+s(e))}}}class a{constructor(r={}){if("string"==typeof r){let e=(r.startsWith("https://")?new URL(r).searchParams.get("ticket"):r).split("_").join("+").split("-").join("/").split(".").join("=");r="undefined"!=typeof Buffer?Uint8Array.from(Buffer.from(e,"base64")).buffer:Uint8Array.from(atob(e),(e=>e.charCodeAt(0))).buffer}if(r instanceof ArrayBuffer){const t=(0,e.sc)(r);this.fromSchema(t.result)}else this.ticket=new l(r.ticket),this.commitment=t(r,"commitment"),this.publicKeyInfo=new o(r.publicKeyInfo),this.signatureValue=t(r,"signatureValue")}static schema(r={}){const s=t(r,"names",{});return new e.T9({name:s.blockName||"SignedDevconTicket",value:[l.schema(r),new e.fi({name:"commitment"}),new e.T9({name:"publicKeyInfo",optional:!0,value:[o.schema(s.publicKeyInfo||{names:{blockName:"publicKeyInfo"}})]}),new e._K({name:"signatureValue"})]})}fromSchema(t){n(t,["ticket","commitment","publicKeyInfo","signatureValue"]);const r=(0,e.eN)(t,t,a.schema());if(!1===r.verified)throw new Error("Object's schema was not verified against input data for SignedDevconTicket");this.ticket=new l(r.result.ticket.valueBeforeDecode),"commitment"in r.result&&(this.commitment=r.result.commitment.valueBlock.valueHex),this.publicKeyInfo=new o({schema:r.result.publicKeyInfo});const s=r.result.signatureValue;this.signatureValue=s.valueBlock.valueHex}}window.Negotiator=class{constructor(e,t={}){this.filter=e,this.debug=0,this.hideTokensIframe=0,this.attestationOrigin="http://stage.attestation.id",this.tokensOrigin="https://devcontickets.herokuapp.com/outlet/",t.hasOwnProperty("debug")&&(this.debug=t.debug),t.hasOwnProperty("attestationOrigin")&&(this.attestationOrigin=t.attestationOrigin),t.hasOwnProperty("tokensOrigin")&&(this.tokensOrigin=t.tokensOrigin)}getTokenInstances(){let e=[];if(this.debug&&console.log("filter:",this.filter),this.tokens.web.length&&"object"==typeof this.filter&&Object.keys(this.filter).length){let t=Object.keys(this.filter);return this.tokens.web.forEach((r=>{let s=1;this.debug&&console.log("test token:",r),t.forEach((e=>{r[e].toString()!=this.filter[e].toString()&&(s=0)})),s&&(e.push(r),this.debug&&console.log("token fits:",r))})),e}return this.tokens.web}negotiate(e){window.addEventListener?window.addEventListener("message",(t=>{this.parentPostMessagelistener(t,e)})):window.attachEvent("onmessage",(t=>{this.parentPostMessagelistener(t,e)}));const t=document.createElement("iframe");this.tokensIframe=t,this.hideTokensIframe&&(t.style.display="none");const r=this.tokensOrigin;t.src=r,document.body.appendChild(t)}base64ToUint8array(e){let t;return e=e.split("_").join("+").split("-").join("/").split(".").join("="),t="undefined"!=typeof Buffer?Uint8Array.from(Buffer.from(e,"base64")):Uint8Array.from(atob(e),(e=>e.charCodeAt(0))),t}decodeTokens(e,t){this.debug&&(console.log("decodeTokens fired"),console.log(e)),this.tokens={raw:[],web:[]},e.length&&(e.forEach((e=>{let t=new a(this.base64ToUint8array(e.ticket).buffer);console.log("decodedToken = ",t),this.tokens.raw.push(e),t&&this.tokens.web.push(t.ticket)})),t&&t(this.getTokenInstances()))}parentPostMessagelistener(e,t){void 0!==e.data.tokens&&(this.debug&&console.log("---parent postMessage event received, event.data.tokens:",e.data.tokens),this.tokensIframe.remove(),this.decodeTokens(JSON.parse(e.data.tokens),t))}}})()})();